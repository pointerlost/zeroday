#version 460
layout(local_size_x = 64) in;

#include "common/constants.glsl"

// Metadata table (per entity)
struct RenderCommandMDI {
    uint vao;
    uint materialIndex;
    uint transformIndex;
    uint indexCount;
    uint indexOffset;
};

layout(std430, binding = BINDING_ENTITY_METADATA) buffer EntityDataBuffer {
    RenderCommandMDI entities[];
}

// No visibility buffer needed - draw ALL entities
uniform uint totalEntityCount;

// Output: Indirect draw commands (one per entity)
layout(std430, binding = BINDING_COMMANDS) buffer IndirectCommands {
    DrawElementsIndirectCommand commands[];
};

// Output: Draw payloads (per draw call data)
layout(std430, binding = BINDING_PAYLOADS) buffer DrawPayloads {
    DrawPayloadGPU payloads[];
};

void main() {
    uint entityIndex = gl_GlobalInvocationID.x;

    // Draw ALL entities (no culling check yet!)
    if (entityIndex >= totalEntityCount) return;

    // Each entity gets its own draw command
    uint commandIndex = entityIndex;

    // Fill indirect draw command
    commands[commandIndex].count         = uint(entities[entityIndex].indexCount);
    commands[commandIndex].instanceCount = uint(1);
    commands[commandIndex].firstIndex    = uint(entities[entityIndex].indexOffset);
    commands[commandIndex].baseVertex    = uint(0);
    commands[commandIndex].baseInstance  = uint(commandIndex);

    // Fill payload data for vertex shader
    payloads[commandIndex].transformIndex = int(entities[entityIndex].transformIndex);
    payloads[commandIndex].materialIndex  = int(entities[entityIndex].materialIndex);
    payloads[commandIndex].meshId         = int(entities[entityIndex].vao);
    payloads[commandIndex].entityId       = int(entityIndex)
}
#ifndef LIGHTING_CALCULATIONS
#define LIGHTING_CALCULATIONS

#include "common/light_data.glsl"
#include "common/camera_data.glsl"
#include "compute/pbr_calc.comp"

// -------------------
// Light models (require world space positions/normals)
vec3 CalcDirectionalLight(LightData light, MaterialData material, vec3 worldPos, vec3 worldNormal) {
    vec3 L = normalize(-light.direction);  // light.direction in world space
    vec3 V = normalize(uCamera.cameraPosition - worldPos);  // View vector in world space

    return CalcPBR(material, worldNormal, V, L, light.radiance * light.intensity);
}

vec3 CalcPointLight(LightData light, MaterialData material, vec3 worldPos, vec3 worldNormal) {
    vec3 L = normalize(light.position - worldPos);  // Both in world space!
    vec3 V = normalize(uCamera.cameraPosition - worldPos);

    float d = length(light.position - worldPos);
    float attenuation = 1.0 / (light.constant + light.linear * d + light.quadratic * d * d);

    return CalcPBR(material, worldNormal, V, L, light.radiance * light.intensity) * attenuation;
}

vec3 CalcSpotLight(LightData light, MaterialData material, vec3 worldPos, vec3 worldNormal) {
    vec3 L = normalize(light.position - worldPos);
    vec3 V = normalize(uCamera.cameraPosition - worldPos);

    float theta = dot(L, normalize(-light.direction));
    float epsilon = light.cutOff - light.outerCutOff;
    float spotFactor = clamp((theta - light.outerCutOff) / max(epsilon, 1e-5), 0.0, 1.0);

    float d = length(light.position - worldPos);
    float attenuation = 1.0 / (light.constant + light.linear * d + light.quadratic * d * d);

    return CalcPBR(material, worldNormal, V, L, light.radiance * light.intensity) * attenuation * spotFactor;
}

#endif